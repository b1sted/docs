---
title: "Лекция 14: Работа с динамической памятью"
---

> "Понимание позволяет понимать"

***

## Введение в динамическую память

Динамическая память выделяется во время выполнения программы, что позволяет гибко управлять объемом памяти в зависимости от потребностей. В отличие от статической памяти, размер которой фиксирован на этапе компиляции, динамическая память предоставляет больше свободы в работе с большими и изменяемыми объемами данных.

### **Преимущества динамической памяти**

* Позволяет создавать структуры данных, размер которых неизвестен заранее (например, массивы переменной длины).
* Упрощает управление ресурсами для сложных программ.

### **Структура памяти программы**

Память программы делится на несколько сегментов:

* **Стек** : используется для локальных переменных и аргументов функций. Работает по принципу LIFO (Last In, First Out).
* **Куча** : область динамической памяти. Выделение и освобождение памяти в куче осуществляется вручную.
* **Сегмент данных** : хранит глобальные переменные.
* **Сегмент кода** : содержит исполняемый код программы.

***

## Функции для динамического распределения памяти

Для управления динамической памятью в языке C используется стандартная библиотека \<stdlib.h>, которая предоставляет функции:

* **`malloc(size_t size)`**: выделяет блок памяти указанного размера.
* **`calloc(size_t n, size_t size)`**: выделяет память для массива из элементов и инициализирует их нулями.
* **`realloc(void *ptr, size_t size)`**: изменяет размер ранее выделенного блока памяти.
* **`free(void *ptr)`**: освобождает ранее выделенную память.

Пример использования:

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    int *arr = (int *)malloc(5 * sizeof(int)); // Выделение памяти для 5 элементов
    if (arr == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    for (int i = 0; i < 5; i++) {
        arr[i] = i * i; // Заполнение массива
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr); // Освобождение памяти
    return 0;
}
```

***

## Использование функций `malloc` и `free`

### **Основные правила**

1. Всегда проверяйте, что результат вызова `malloc` или `calloc` не равен `NULL`.
2. После завершения работы с памятью обязательно вызывайте `free`, чтобы избежать утечек.
3. Никогда не используйте указатель после вызова `free` .

Пример с проверкой выделения памяти:

```c
int *ptr = (int *)malloc(10 * sizeof(int));
if (!ptr) {
    printf("Ошибка: не удалось выделить память\n");
    exit(EXIT_FAILURE);
}
free(ptr);
```

***

## Одномерные динамические массивы

Одномерный динамический массив — это массив, размер которого определяется во время выполнения программы.

Пример создания массива:

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    int n;
    printf("Введите размер массива: ");
    scanf("%d", &n);

    int *arr = (int *)malloc(n * sizeof(int));
    if (arr == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    for (int i = 0; i < n; i++) {
        arr[i] = i + 1;
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}
```

***

## Динамическое выделение памяти для двумерных массивов

Для двумерных массивов память можно выделять двумя способами:

1. **Одним блоком ("лента")**:

```c
int *matrix = (int *)malloc(rows * cols * sizeof(int));
```

Доступ к элементу: `matrix[i * cols + j]`.

2. **Массив указателей**:

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    int rows, cols;
    printf("Введите количество строк и столбцов: ");
    scanf("%d %d", &rows, &cols);

    int **matrix = (int **)malloc(rows * sizeof(int *));
    for (int i = 0; i < rows; i++) {
        matrix[i] = (int *)malloc(cols * sizeof(int));
    }

    // Заполнение и вывод
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = i + j;
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    // Освобождение памяти
    for (int i = 0; i < rows; i++) {
        free(matrix[i]);
    }
    free(matrix);

    return 0;
}
```

***

## Заключение

Работа с динамической памятью открывает широкие возможности для управления ресурсами, но требует осторожности. Ошибки, такие как утечки памяти или обращение к невалидным адресам, могут привести к сбоям программы. В современных языках (например, Python или Java) эти проблемы решаются с помощью автоматического управления памятью, но в C/C++ программисты несут полную ответственность за память, что требует дисциплины и внимания.

***

> [Let the bodies hit the floor <br />
> Let the bodies hit the floor <br />
> Let the bodies hit the floor <br />
> Let the bodies hit the floor](https://youtu.be/04F4xlWSFh0)
