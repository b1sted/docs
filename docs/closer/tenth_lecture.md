---
title: "Лекция 10: Указатели в языке Си"
---

> [_"What the fuck is this piece of shit?" - Джо Пеши_](https://youtu.be/sMnmQuLzoks?feature=shared)

<hr class="custom-divider">

## Предисловие

!!! info
    > 'Это, пожалуй, самая сложная и самая важная тема во всём курсе. Без понимания указателей дальнейшее изучении си будет бессмысленным. Указатели – простая концепция, логичная, но требующая внимания к деталям.' - L-10.YkazatelivyazikeSi.pptx


<hr class="custom-divider">

## Указатели в языке Си

**Указатель** — это переменная, которая хранит **адрес в памяти** другой переменной. Представьте, что это как номер квартиры, по которому можно найти жильца (данные). Чтобы создать указатель, нужно указать тип данных и использовать звёздочку (`*`), например:

```c
int *p;
```

Здесь `p` — указатель на `int` (целое число). Получить адрес переменной можно с помощью `&`, а получить данные по адресу — с помощью `*`. Например:

```c
int a = 5;
int *p = &a;  // p хранит адрес a
```

Теперь `*p` — это значение переменной `a`.

<hr class="custom-divider">

## Операции над указателями

С указателями можно выполнять разные операции, такие как:

1. **Присваивание**: указателю можно присвоить адрес, например `p = &a`.
2. **Разыменование**: операция `*p` получает значение по адресу.
3. **Арифметика**: можно прибавлять или вычитать числа, чтобы сдвигать указатель по массиву (если `p` указывает на массив).

**Пример:**

```c
int arr[] = {10, 20, 30};
int *p = arr;
p++;  // теперь p указывает на второй элемент массива, то есть на 20
```

<hr class="custom-divider">

## **Представление указателей в памяти**

Указатели в языке Си хранятся как переменные, которые содержат адреса других объектов. Независимо от типа данных, на который указывает указатель, он занимает фиксированное количество памяти (обычно 4 байта на 32-битной системе и 8 байт на 64-битной).

Рассмотрим пример с двумя указателями, ссылающимися на разные переменные:

```c
int a = 10;
float b = 20.5;
int *p = &a;      // Указатель на переменную a
float *q = &b;    // Указатель на переменную b
```

Предположим, `a` хранится по адресу `0x100`, `b` — по адресу `0x200`. Указатели `p` и `q` будут хранить эти адреса:

| Переменная | Тип данных | Значение  | Адрес хранения переменной | Адрес хранения указателя | Значение указателя (содержимое) |
|------------|------------|-----------|---------------------------|--------------------------|---------------------------------|
| `a`        | `int`      | 10        | `0x100`                   |                          |                                 |
| `b`        | `float`    | 20.5      | `0x200`                   |                          |                                 |
| `p`        | `int*`     | Адрес `a` |                           | `0x300`                  | `0x100` (адрес переменной `a`)  |
| `q`        | `float*`   | Адрес `b` |                           | `0x304`                  | `0x200` (адрес переменной `b`)  |


### **Объяснение работы с указателями**

Когда мы разыменовываем указатель (например, `*p`), компилятор использует адрес, хранящийся в указателе, чтобы получить значение переменной, на которую он указывает. Так:

* `*p` вернёт значение `10`, так как `p` указывает на адрес `0x100`, где хранится `a`.
* `*q` вернёт значение `20.5`, так как `q` указывает на адрес `0x200`, где хранится `b`.

Таким образом, указатели позволяют хранить адреса других переменных и обеспечивают доступ к значениям, хранящимся по этим адресам.

<hr class="custom-divider">

## Нетипизированный указатель (void\*)

`void*` — это указатель, который может хранить адрес любого типа данных, но его нельзя разыменовывать напрямую. Преобразование такого указателя в типизированный позволяет использовать его с определёнными данными:

```c
void *ptr;
int a = 10;
ptr = &a;
int *p = (int *)ptr;  // теперь p указывает на a
```

<hr class="custom-divider">

## Указатели и const

Указатель может быть объявлен так, что значение по адресу или сам адрес нельзя изменить:

* `const int *p` — нельзя изменить значение, на которое указывает `p`.
* `int *const p` — нельзя изменить сам указатель `p`.
* `const int *const p` — ни значение, ни указатель менять нельзя.

**Пример:**

```c
const int *p = &a; // *p = 6; — ошибка, нельзя изменить значение через указатель
```

<hr class="custom-divider">

## Указатель на указатель

Указатель может указывать на другой указатель, это называется **указатель на указатель**. Они используются для работы с многомерными массивами и более сложными структурами.

```c
int a = 10;
int *p = &a;
int **pp = &p;
```

Теперь `**pp` вернёт значение `a`.

<hr class="custom-divider">

## Указатель файла

Работа с файлами в Си выполняется с помощью указателя на структуру `FILE`. Для работы с файлами подключается библиотека `<stdio.h>`, а указатель объявляется как:

```c
FILE *file_ptr;
```

Этот указатель управляет доступом к файлу. Для открытия файла используют `fopen`, а для закрытия — `fclose`.

**Пример:**

```c
FILE *file_ptr = fopen("data.txt", "r");
if (file_ptr != NULL) {
    // работа с файлом
    fclose(file_ptr);
}
```

<hr class="custom-divider">

## Указатели и массивы

В языке Си имя массива — это константный указатель на его первый элемент, так что `arr[i]` можно записать как `*(arr + i)`.

**Пример:**

```c
int arr[] = {10, 20, 30};
int *p = arr;
printf("%d", *(p + 2));  // Вывод: 30
```

<hr class="custom-divider">

## Указатели на функции

Указатели могут хранить адреса функций, что полезно для передачи функций в качестве параметров. Указатель на функцию объявляется так:

```c
int (*func_ptr)(int, int);
```

Где `func_ptr` — указатель на функцию, принимающую два `int` и возвращающую `int`.

**Пример:**

```c
int add(int a, int b) { return a + b; }
int (*func_ptr)(int, int) = add;
printf("%d", func_ptr(3, 4));  // Вывод: 7
```

<hr class="custom-divider">

> [_I have found, you can find happiness in slavery_](https://www.youtube.com/watch?v=mQ2-SkLfldk\&pp=ygUUaGFwcGluZXNzIGluIHNsYXZlcnk%3D)
