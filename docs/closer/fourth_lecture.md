---
title: "Лекция 4: Система типов в языке Си"
---

> _В мужчине днем должно быть всё светлое, а ночью - тёмное. Даже пиво._

<hr class="custom-divider">

## Тип данных

Тип данных определяет множество возможных значений переменной и допустимые операции над ними. В языке C есть основные типы:

* **Символьный (**`char`**)**: занимает 1 байт, используется для хранения символов.
* **Целый (**`int`**)**: размер зависит от системы, часто соответствует машинному слову.
* **Вещественный (**`float`**)**: 32 бита, диапазон значений от 3.4e-38 до 3.4e+38.
* **Двойной точности (**`double`**)**: 64 бита, больший диапазон и точность, чем `float`.
* **Тип без значения (**`void`**)**: используется для функций, не возвращающих значений.

Также типы могут быть модифицированы с помощью `signed`, `unsigned`, `short`, и `long`:

* **`signed`**: хранит положительные и отрицательные значения. Например, `signed int` от -32768 до 32767 (для 16 бит).
* **`unsigned`**: только положительные значения. `unsigned int` от 0 до 65535 (для 16 бит).
* **`short`**: уменьшает размер, обычно до 2 байт. `short int` от -32768 до 32767 (signed) или 0 до 65535 (unsigned).
* **`long`**: увеличивает размер, до 4 или 8 байт. Например, `long int` от -2147483648 до 2147483647 (для 32 бит).

```c
#include <stdio.h>

int main() {
    // signed int: может хранить отрицательные и положительные значения
    signed int signedInt = -32768;
    printf("Signed int: %d\n", signedInt);

    // unsigned int: хранит только положительные значения
    unsigned int unsignedInt = 65535;
    printf("Unsigned int: %u\n", unsignedInt);

    // short int: занимает меньше памяти (обычно 2 байта)
    short int shortInt = 32767;
    printf("Short int: %d\n", shortInt);

    // unsigned short int: только положительные значения, но меньше диапазон
    unsigned short int unsignedShortInt = 65535;
    printf("Unsigned short int: %u\n", unsignedShortInt);

    // long int: расширенный диапазон для хранения больших чисел
    long int longInt = 2147483647;
    printf("Long int: %ld\n", longInt);

    // unsigned long int: хранит только положительные, но большие значения
    unsigned long int unsignedLongInt = 4294967295;
    printf("Unsigned long int: %lu\n", unsignedLongInt);

    return 0;
}
```

<hr class="custom-divider">

## Переменные и константы

**Переменные** — именованные объекты, которые хранят данные и могут изменяться в ходе программы.&#x20;

**Константы** — неизменные значения, такие как:

* **Вещественные константы**: 123.456 или 5.61e-4.
* **Целые и длинные целые**: с суффиксами `L` или `U` (например, `361327L`).
* **Шестнадцатеричные**: с префиксом `0x` (например, `0x5F`).
* **Символьные константы**: заключены в одинарные кавычки (`'a'`).

```c
#include <stdio.h>

int main() {
    // Переменные
    int x = 10;                // целочисленная переменная
    double y = 3.14;          // вещественная переменная

    // Константы
    const double PI = 3.14159; // вещественная константа
    const int MAX_VALUE = 100;  // целочисленная константа
    const long LONG_VALUE = 361327L; // длинная целочисленная константа
    const int HEX_VALUE = 0x5F; // шестнадцатеричная константа
    const char CHARACTER = 'a';  // символьная константа

    // Изменение переменной
    x += 5;

    // Вывод значений
    printf("x = %d\n", x);              // 15
    printf("y = %f\n", y);              // 3.14
    printf("PI = %f\n", PI);            // 3.141590
    printf("MAX_VALUE = %d\n", MAX_VALUE); // 100
    printf("LONG_VALUE = %ld\n", LONG_VALUE); // 361327
    printf("HEX_VALUE = %X\n", HEX_VALUE); // 5F
    printf("CHARACTER = %c\n", CHARACTER); // a

    return 0;
}
```

<hr class="custom-divider">

## Преобразование типов

При операциях с разными типами данных C автоматически преобразует их к общему типу, но возможны и явные преобразования с помощью `(тип) выражение`.&#x20;

```c
#include <stdio.h>

int main() {
    int a = 30000;     // целочисленная переменная
    float b;          // вещественная переменная

    b = (float) a * 12; // приведение типа и вычисление

    // Вывод результата
    printf("Значение a: %d\n", a);          // 30000
    printf("Значение b: %.2f\n", b);        // 360000.00

    return 0;
}
```

<hr class="custom-divider">

## Составные типы и указатели

* **Массивы**: коллекции элементов одного типа, например `int a[10];`.
* **Структуры**: набор переменных разных типов, объединённых под одним именем.
* **Объединения**: схожи со структурами, но могут содержать только одно значение в любой момент времени.
* **Указатели**: хранят адреса переменных и используются часто.

```c
#include <stdio.h>

// Определение структуры Person для хранения информации о человеке
struct Person {
    char name[50]; // Массив символов для хранения имени
    int age;       // Целочисленная переменная для хранения возраста
};

// Определение объединения Data, которое может хранить разные типы данных
union Data {
    int intValue;      // Целое значение
    float floatValue;  // Значение с плавающей запятой
    char charValue;    // Символьное значение
};

int main() {
    // Объявление массива целых чисел размером 10
    int a[10]; // массив из 10 целых чисел

    // Инициализация массива значениями
    for (int i = 0; i < 10; i++) {
        a[i] = i * 10; // Присваиваем каждому элементу массива значение i * 10
    }

    // Создание экземпляра структуры Person
    struct Person person;
    snprintf(person.name, sizeof(person.name), "Alice"); // Заполнение имени
    person.age = 30; // Установка возраста

    // Создание экземпляра объединения Data
    union Data data;
    data.intValue = 42; // Запись целого числа в объединение

    // Указатель на первый элемент массива a
    int *ptr = a; // Указатель на массив

    // Вывод значений массива
    printf("Массив a:\n");
    for (int i = 0; i < 10; i++) {
        printf("a[%d] = %d\n", i, ptr[i]); // Использование указателя для доступа к элементам массива
    }

    // Вывод информации о структуре Person
    printf("\nСтруктура Person:\n");
    printf("Имя: %s, Возраст: %d\n", person.name, person.age);

    // Вывод значений из объединения Data
    printf("\nОбъединение Data:\n");
    printf("Целое значение: %d\n", data.intValue); // Вывод целого значения из объединения
    
    // Запись другого значения в объединение
    data.floatValue = 3.14f; // Запись значения с плавающей запятой
    printf("Плавающее значение: %.2f\n", data.floatValue); // Вывод значения с плавающей запятой

    return 0; // Завершение программы
}
```

<hr class="custom-divider">

## Оператор `typedef`

Оператор `typedef` в языке C позволяет создавать псевдонимы для существующих типов данных. Это упрощает написание и чтение кода, особенно когда речь идет о сложных типах, таких как структуры, указатели или массивы.

```c
#include <stdio.h> // Подключение библиотеки для ввода-вывода

// Определение структуры Person с использованием оператора typedef
typedef struct {
    char name[50]; // Массив символов для хранения имени (максимум 49 символов + 1 для завершающего нуля)
    int age;       // Целочисленная переменная для хранения возраста
} Person; // Теперь можно использовать Person как тип

// Определение указателя на структуру Person с использованием оператора typedef
typedef Person* PersonPtr; // PersonPtr теперь является алиасом для указателя на Person

int main() {
    // Создание переменной типа Person
    Person person; // Используем тип Person

    // Инициализация поля name структуры person
    snprintf(person.name, sizeof(person.name), "Alice"); // Копируем строку "Alice" в поле name
    person.age = 30; // Установка возраста для структуры person

    // Создание указателя на переменную person
    PersonPtr ptr = &person; // Используем тип PersonPtr, который является указателем на Person

    // Вывод информации о человеке, разыменовывая указатель
    printf("Имя: %s, Возраст: %d\n", ptr->name, ptr->age); // Используем оператор -> для доступа к полям структуры через указатель

    return 0; // Завершение программы
}
```

<hr class="custom-divider">

## Логический тип и комплексные числа

* В C89 логический тип представлен `int` (0 — false, не 0 — true).

```c
#include <stdio.h> // Подключение библиотеки для ввода-вывода

int main() {
    int a = 5;    // Инициализация целочисленной переменной a (не 0, значит true)
    int b = 0;    // Инициализация целочисленной переменной b (0, значит false)

    // Проверка логических условий
    if (a) { // Проверка, является ли a истинным (не 0)
        printf("a is true (non-zero)\n"); // Печатает, так как a != 0
    }
    if (!b) { // Проверка, является ли b ложным (0)
        printf("b is false (zero)\n"); // Печатает, так как b == 0
    }

    return 0; // Завершение программы
}
```

* В C99 введён `_Bool`, для которого можно использовать `stdbool.h` и типы `bool`, `true`, `false`.

```c
#include <stdio.h> // Подключение библиотеки для ввода-вывода
#include <stdbool.h> // Подключаем библиотеку для использования типа bool

int main() {
    bool isTrue = true;  // Используем тип bool, задаем значение true
    bool isFalse = false; // Используем тип bool, задаем значение false

    // Проверка логических условий
    if (isTrue) { // Проверяем, является ли isTrue истинным
        printf("isTrue is true\n"); // Печатает, так как isTrue == true
    }
    if (!isFalse) { // Проверяем, является ли isFalse ложным
        printf("isFalse is false\n"); // Печатает, так как isFalse == false
    }

    return 0; // Завершение программы
}
```

* Комплексные числа также добавлены в C99 с типами `float _Complex`, `double _Complex`.

```c
#include <stdio.h> // Подключение библиотеки для ввода-вывода
#include <complex.h> // Подключаем библиотеку для работы с комплексными числами

int main() {
    // Объявление комплексного числа z1 с действительной частью 1.0 и мнимой частью 2.0
    double complex z1 = 1.0 + 2.0 * I; 
    // Объявление комплексного числа z2 с действительной частью 3.0 и мнимой частью 4.0
    double complex z2 = 3.0 + 4.0 * I; 

    // Сложение комплексных чисел z1 и z2, результат сохраняется в переменной result
    double complex result = z1 + z2;

    // Вывод суммы комплексных чисел
    // creal() возвращает действительную часть, cimag() возвращает мнимую часть
    printf("Сумма: %.2f + %.2fi\n", creal(result), cimag(result)); // Выводим действительную и мнимую части

    return 0; // Завершение программы
}
```

<hr class="custom-divider">

## Абстракция и иерархия типов

**Абстракция** позволяет скрывать сложные детали и представлять данные на высоком уровне, упрощая работу с ними. Например, используя структуры, мы можем объединить связанные переменные, такие как имя и возраст, в один логический объект:

```c
#include <stdio.h> // Подключение библиотеки для ввода-вывода

// Определение структуры Person для абстракции данных
typedef struct {
    char name[50]; // Массив для хранения имени
    int age;       // Целочисленная переменная для хранения возраста
} Person; // Теперь можно использовать Person как тип

// Функция для вывода информации о человеке
void printPerson(Person p) {
    printf("Имя: %s, Возраст: %d\n", p.name, p.age); // Вывод имени и возраста
}

int main() {
    // Создание экземпляра структуры Person и инициализация
    Person person;
    snprintf(person.name, sizeof(person.name), "Alice"); // Заполнение имени
    person.age = 30; // Установка возраста

    // Вызов функции для вывода информации о человеке
    printPerson(person); // Печатает: Имя: Alice, Возраст: 30

    return 0; // Завершение программы
}
```

Пример демонстрирует, как структура `Person` позволяет абстрагировать информацию о человеке. Мы создаём экземпляр структуры и используем функцию `printPerson`, чтобы вывести информацию.

**Иерархия типов** организует типы данных в более сложные структуры, облегчая повторное использование кода. Например, мы можем создать перечисление для дней недели и использовать его в структуре:

```c
#include <stdio.h> // Подключение библиотеки для ввода-вывода

// Определение перечисления для дней недели
typedef enum {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
} Day; // Перечисление позволяет использовать понятные названия для дней

// Определение структуры Event для представления события
typedef struct {
    char title[100]; // Массив для хранения названия события
    Day day;         // Использование перечисления для дня события
} Event; // Теперь можно использовать Event как тип

// Функция для вывода информации о событии
void printEvent(Event e) {
    const char *days[] = {"Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"};
    printf("Событие: %s, День: %s\n", e.title, days[e.day]); // Вывод названия и дня события
}

int main() {
    // Создание экземпляра структуры Event и инициализация
    Event meeting;
    snprintf(meeting.title, sizeof(meeting.title), "Встреча с командой"); // Заполнение названия события
    meeting.day = FRIDAY; // Установка дня события

    // Вызов функции для вывода информации о событии
    printEvent(meeting); // Печатает: Событие: Встреча с командой, День: Пятница

    return 0; // Завершение программы
}
```

Пример показывает, как мы можем использовать перечисление `Day` и структуру `Event` для создания иерархии типов. Это позволяет нам организовать данные о событиях и легко управлять ими.

<hr class="custom-divider">

> [I feel so alone\
> Gonna end up a big ol' pile of them bones](https://www.youtube.com/watch?v=zTuD8k3JvxQ\&pp=ygUKdGhlbSBib25lcw%3D%3D)
