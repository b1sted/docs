---
title: "Лекция 11: Двумерные массивы"
---

> _"Я не боюсь того, кто учит 10 тысячам строкам кода на C_<br />
> _Я боюсь геморроидального узла"_<br />
> _&mdash; Уильям Дефо_

<hr class="custom-divider">

## **Введение в двумерные массивы**

**Массив** — это структура данных, состоящая из элементов одного типа, которые хранятся последовательно в памяти. Одномерные массивы представляют линейные структуры данных (например, векторы), тогда как **двумерные массивы** используются для работы с более сложными структурами данных, такими как матрицы, таблицы или экраны. В языке C двумерный массив — это по сути массив одномерных массивов, где каждый элемент массива имеет два индекса: номер строки и номер столбца.

<hr class="custom-divider">

## Низкоуровневая абстракция и двумерные массивы&#x20;

В языке C массивы реализуются на низком уровне, что позволяет эффективно управлять памятью и работать с данными. Каждый элемент двумерного массива хранится последовательно в памяти, что делает доступ к элементам очень быстрым. Например, массив `int matrix[3][4]` будет занимать один непрерывный блок памяти размером 12 ячеек (3 строки и 4 столбца), где первый индекс (строка) меняется медленнее, чем второй (столбец). Это называется построчным порядком хранения данных.

Когда мы обращаемся к элементу `matrix[i][j]`, компилятор переводит это в операцию сдвига указателя, вычисляя положение элемента в памяти как `base_address + (i * columns + j) * size_of(int)`. Такой подход к организации данных является примером низкоуровневой абстракции, так как он связывает понятие массива с непосредственным расположением данных в памяти.

Подробнее про низкоуровневую абстракцию можно прочитать в статье [`"Почему же Хазиев имеет право называть массивы фикцией?"`](../strange/fiction.md)

<hr class="custom-divider">

## **Объявление двумерных массивов**

Двумерный массив объявляется следующим образом:

```c
<тип данных> <имя массива>[количество строк][количество столбцов];
```

Пример:

```c
int matrix[3][4];
```

Здесь `matrix` — массив целых чисел, состоящий из 3 строк и 4 столбцов.

* Первый индекс (например, `matrix[0][0]`) указывает номер строки.
* Второй индекс — номер столбца.

> **Примечание**: В C индексы начинаются с 0.

<hr class="custom-divider">

## **Инициализация двумерных массивов**

Двумерные массивы можно инициализировать сразу при объявлении:

```c
int matrix[2][2] = {{1, 2}, {3, 4}};
```

Также можно инициализировать массив, опуская первый размер:

```c
int matrix[][2] = {{1, 2}, {3, 4}};
```

Компилятор определит размерность массива, исходя из количества элементов.

<hr class="custom-divider">

## **Доступ к элементам массива**

Элементы массива можно изменять и читать по индексам:

```c
matrix[1][1] = 5;  // Записывает значение 5 во второй строке, втором столбце
int value = matrix[0][1];  // Читает значение из первой строки, второго столбца
```

<hr class="custom-divider">

## **Работа с массивами с помощью циклов**

Для обработки всех элементов двумерного массива удобно использовать вложенные циклы:

```c
const int rows = 3;
const int cols = 4;
int matrix[rows][cols];

for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = i * j;  // Пример заполнения массива
    }
}
```

Здесь внешний цикл проходит по строкам, а внутренний — по столбцам каждой строки.

<hr class="custom-divider">

## **Низкоуровневая абстракция**

В языке C массивы по сути являются указателями на свой первый элемент. Например, для двумерного массива `matrix[3][4]` имя `matrix` указывает на начало первой строки. Компилятор рассчитывает адрес каждого элемента на основе его положения в памяти, что позволяет обращаться к массиву как к непрерывной последовательности данных, доступной через указатели.

Для вычисления адреса элемента `matrix[i][j]` используется формула:

$$
address = \textit{base\_address} + (i \times\ \textit{num\_columns} + j) \times\ sizeof(int)
$$

Эквивалентная запись в C выглядит как `*(*(matrix + i) + j)`: компилятор корректирует указатель по строкам и столбцам, чтобы найти нужный элемент.

### **Пример представления массива в памяти**

Рассмотрим массив `int matrix[3][4]`, содержащий следующие данные:

```c
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```

В памяти он будет располагаться так:

| Адрес | Значение | Индексы        |
| ----- | -------- | -------------- |
| 0x100 | 1        | matrix\[0]\[0] |
| 0x104 | 2        | matrix\[0]\[1] |
| 0x108 | 3        | matrix\[0]\[2] |
| 0x10C | 4        | matrix\[0]\[3] |
| 0x110 | 5        | matrix\[1]\[0] |
| 0x114 | 6        | matrix\[1]\[1] |
| 0x118 | 7        | matrix\[1]\[2] |
| 0x11C | 8        | matrix\[1]\[3] |
| 0x120 | 9        | matrix\[2]\[0] |
| 0x124 | 10       | matrix\[2]\[1] |
| 0x128 | 11       | matrix\[2]\[2] |
| 0x12C | 12       | matrix\[2]\[3] |

Каждый элемент занимает 4 байта, и адрес следующего увеличивается на 4 байта. Адрес `matrix[i][j]` рассчитывается по формуле:

$$
address = \textit{base\_address} + (i \times\ \textit{num\_columns} + j) \times\ sizeof(int)
$$

Например, элемент `matrix[2][1]` будет по адресу:

$$
0x120 + (2 \times 4 + 1) \times 4 = 0x124
$$

Это пример **построчного размещения**: элементы массива идут подряд, строка за строкой, начиная с первой.

<hr class="custom-divider">

## **Операции с массивами**

### **Пример вычисления суммы всех элементов**:

```c
int sum = 0;
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        sum += matrix[i][j];
    }
}
```

### **Пример заполнения массива случайными числами**:

```c
#include <stdlib.h>
#include <time.h>

srand(time(NULL));  // Инициализация генератора случайных чисел

for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = rand() % 10;  // Случайное число от 0 до 9
    }
}
```

<hr class="custom-divider">

## **Связь двумерных массивов с указателями**

В C имя массива — это указатель на первый элемент массива. Для двумерного массива `matrix[3][4]` указатель `matrix` указывает на начало первой строки. Элементы можно также получать через указательную арифметику:

```c
*(*(matrix + i) + j)  // Эквивалент matrix[i][j]
```

<hr class="custom-divider">

## **Применение двумерных массивов**

* **Графика и таблицы**: Хранение значений для графического интерфейса, например, пикселей изображения.
* **Матрицы в линейной алгебре**: Операции над матрицами, такие как сложение, умножение и нахождение детерминанта.
* **Игровые доски**: Хранение состояния, например, шахматной доски.

<hr class="custom-divider">

## **Пример задачи**

**Нахождение суммы элементов главной диагонали квадратной матрицы**:

```c
int sum = 0;
for (int i = 0; i < N; i++) {
    sum += matrix[i][i];
}
```

<hr class="custom-divider">

## **Заключение**

Двумерные массивы — мощный инструмент для организации данных в языке C. Они позволяют эффективно обрабатывать данные, хранящиеся в табличном формате, и активно используются в графике, вычислениях и других областях программирования.

<hr class="custom-divider">

> [Nothing to prove, nothing to say<br />
> Nothing to lose, nothing to gain<br />
> Nothing to feel, nothing to hate<br />
> Nothing is real, it's all too late](https://www.youtube.com/watch?v=BgDJR-W7DMk\&pp=ygUMZnJlYWtpbicgb3V0)
