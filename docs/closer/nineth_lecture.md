---
title: "Лекция 9: Одномерные массивы"
---

> _"Массивы в C — это как аренда квартиры без замков: никто не следит за границами, и если что-то сломается, то это твоя проблема." - Конфуций_

<hr class="custom-divider">

## Понятие массива. Одномерные массивы

**Массив** — это структура данных, которая позволяет хранить несколько элементов одного типа под общим именем. Каждый элемент массива доступен по индексу, что упрощает доступ к данным и их обработку. Например, чтобы сохранить и обработать возраст пяти человек, можно использовать массив `ages`, где каждый элемент — возраст одного человека:

```c
int ages[5]; // массив для хранения 5 целых чисел
```

Индексы массива в C начинаются с нуля, поэтому `ages[0]` — первый элемент, а `ages[4]` — последний. При создании массива необходимо указать его размер, так как C выделяет память под массив на этапе компиляции.

**Инициализация массива**

Можно задать значения элементов сразу при создании массива:

```c
int ages[5] = {18, 21, 25, 30, 40}; // инициализация массива
```

<hr class="custom-divider">

## Представление в памяти

Массивы в языке C хранятся в памяти компьютера последовательно, как единый блок. Каждый элемент массива занимает одинаковое количество байт, которое зависит от типа данных массива. Например, массив целых чисел `int` занимает 4 байта на элемент (в большинстве систем), тогда как массив символов `char` — 1 байт на элемент.

Когда создаётся массив, компилятор выделяет для него память так, чтобы все элементы шли друг за другом. Это позволяет легко вычислять адрес любого элемента массива, используя начальный адрес массива и смещение, зависящее от индекса.

**Пример представления массива в памяти**

Рассмотрим массив `int numbers[5] = {10, 20, 30, 40, 50};`. Пусть начальный адрес этого массива — `0x100`. Тогда массив в памяти будет выглядеть так:

| Индекс | Значение | Адрес   |
| ------ | -------- | ------- |
| 0      | 10       | `0x100` |
| 1      | 20       | `0x104` |
| 2      | 30       | `0x108` |
| 3      | 40       | `0x10C` |
| 4      | 50       | `0x110` |

Каждый элемент массива `int` занимает 4 байта, поэтому для доступа к следующему элементу добавляется смещение на 4 байта. Например, `numbers[2]` находится по адресу `0x108`.

<hr class="custom-divider">

## Связь указателей и массивов

В C имя массива фактически является указателем на первый элемент. Это значит, что `ages` и `&ages[0]` указывают на один и тот же адрес. Благодаря этому можно работать с массивами, используя как индексы, так и указатели:

```c
int *p = ages; // указатель p указывает на первый элемент массива
printf("%d", *p);       // выводит ages[0]
printf("%d", *(p + 1)); // выводит ages[1]
```

<hr class="custom-divider">

## Строки как одномерные массивы данных типа `char`

Строки в C представляют собой массивы символов `char`, где каждый символ хранится в отдельной ячейке, а последний символ — специальный нуль-символ `\0`, который обозначает конец строки:

```c
char name[] = "Hello"; // строка "Hello", занимает 6 байт (включая `\0`)
```

Для работы со строками в C существуют стандартные функции, такие как `printf`, `scanf`, `strlen` и другие, которые позволяют выполнять различные операции со строками.

**Пример работы со строкой:**

```c
#include <stdio.h>
#include <string.h>

int main() {
    char name[50];
    printf("Введите имя: ");
    scanf("%s", name);  // ввод строки без пробелов
    printf("Ваше имя: %s\n", name);
    printf("Длина строки: %d\n", (int)strlen(name));
    return 0;
}
```

<hr class="custom-divider">

## Примеры обработки массивов

1.  **Увеличение всех элементов массива на 1**:

    ```c
    int nums[3] = {1, 2, 3};
    for (int i = 0; i < 3; i++) {
        nums[i]++;
    }
    ```
2.  **Поиск минимального элемента массива**:

    ```c
    int nums[5] = {5, 3, 8, 1, 4};
    int min = nums[0];
    for (int i = 1; i < 5; i++) {
        if (nums[i] < min) {
            min = nums[i];
        }
    }
    printf("Минимальное значение: %d\n", min);
    ```
3.  **Циклический сдвиг массива влево**:

    ```c
    int nums[5] = {1, 2, 3, 4, 5};
    int first = nums[0];
    for (int i = 0; i < 4; i++) {
        nums[i] = nums[i + 1];
    }
    nums[4] = first;
    ```
4.  **Реверс массива с использованием указателей**:

    ```c
    int nums[5] = {1, 2, 3, 4, 5};
    int *start = nums;
    int *end = nums + 4;
    while (start < end) {
        int temp = *start;
        *start = *end;
        *end = temp;
        start++;
        end--;
    }
    ```

<hr class="custom-divider">

## Передача массивов в функции

В C массивы **не передаются в функции полностью**. Когда мы передаем массив как аргумент функции, **в функцию передается только указатель на первый элемент массива**, а не его копия. Это значит, что любые изменения, сделанные с элементами массива в функции, будут затрагивать исходный массив.

**Пример передачи массива в функцию:**

```c
#include <stdio.h>

void doubleValues(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2; // изменяем элементы массива
    }
}

int main() {
    int nums[5] = {1, 2, 3, 4, 5};
    doubleValues(nums, 5); // передаем массив в функцию

    printf("Измененный массив: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", nums[i]); // вывод измененных значений
    }
    return 0;
}
```

В этом примере функция `doubleValues` получает указатель на `nums`. Когда мы изменяем `arr[i]` в функции, это влияет на исходный массив `nums`, так как в функции обрабатываются те же ячейки памяти.

<hr class="custom-divider">

## Заключение

Одномерные массивы в C — это важная часть работы с данными. Они позволяют хранить последовательные значения в памяти и эффективно обрабатывать их с помощью индексов и указателей. Эти навыки являются основой для работы с более сложными структурами данных, такими как строки, многомерные массивы и указатели на массивы.

<hr class="custom-divider">

> [Моя страсть к массивам мне очень нравится<br />
> Пишу массивы, и они повторяются<br />
> Люблю смотреть, как ошибки из них осыпаются<br />
> Пишу массивы, и они повторяются](https://www.youtube.com/watch?v=jxLYYf5bz0M\&pp=ygUt0LHRg9C10YDQsNC6INGB0YLRgNCw0YHRgtGMINC6INC60YPRgNC10L3QuNGO)
